/*
 ==============================================================================
 
 This file was auto-generated by the Introjucer!
 
 It contains the basic framework code for a JUCE plugin processor.
 
 ==============================================================================
 */

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <math.h>


//==============================================================================
NewProjectAudioProcessor::NewProjectAudioProcessor()
{
    LP.set_Frequency(custom.get_LPFreqValue());
    LP.set_Q(custom.get_LPQValue());
    HP.set_Frequency(custom.get_HPFreqValue());
    HP.set_Q(custom.get_HPQValue());
    
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            //xHP[i][j] = 0;
            //yHP[i][j] = 0;
            
            xLFPeak[i][j] = 0;
            yLFPeak[i][j] = 0;
            xLFShelf[i][j] = 0;
            yLFShelf[i][j] = 0;
            xLFNotch[i][j] = 0;
            yLFNotch[i][j] = 0;
            xLFAllpass[i][j] = 0;
            yLFAllpass[i][j] = 0;
            
            xLMFPeak[i][j] = 0;
            yLMFPeak[i][j] = 0;
            xLMFShelf[i][j] = 0;
            yLMFShelf[i][j] = 0;
            xLMFNotch[i][j] = 0;
            yLMFNotch[i][j] = 0;
            
            xHMFPeak[i][j] = 0;
            yHMFPeak[i][j] = 0;
            xHMFShelf[i][j] = 0;
            yHMFShelf[i][j] = 0;
            xHMFNotch[i][j] = 0;
            yHMFNotch[i][j] = 0;
            
            xHFPeak[i][j] = 0;
            yHFPeak[i][j] = 0;
            xHFShelf[i][j] = 0;
            yHFShelf[i][j] = 0;
            xHFNotch[i][j] = 0;
            yHFNotch[i][j] = 0;
            
            initAllParameters();
        }
    }
}

NewProjectAudioProcessor::~NewProjectAudioProcessor()
{
}

//==============================================================================
const String NewProjectAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

void NewProjectAudioProcessor::initParameters(){
    addFloatParam(LFGain, "LFGain", true, SAVE, &custom.LFGainValue, 0.f, 10.f);
    addFloatParam(LFShape, "LFShape", true, SAVE, &custom.LFShapeValue, 0.f, 1.f);
    addFloatParam(LFFreq, "LFFreq", true, SAVE, &custom.LFFreqValue, 20.f, 340.f);
    addFloatParam(LFQ, "LFQ", true, SAVE, &custom.LFQValue, 0.5, 3.f);
    addBoolParam(LFPos, "LFPos", true, SAVE, &custom.LFPosBool);
    addBoolParam(LFPN, "LFPN", true, SAVE, &custom.LFPNBool);
    addBoolParam(LFEnable, "LFEnable", true, SAVE, &custom.LFEnableBool);
    addFloatParam(LMFGain, "LMFGain", true, SAVE, &custom.LMFGainValue, 0.f, 10.f);
    addFloatParam(LMFShape, "LMFShape", true, SAVE, &custom.LMFShapeValue, 0.f, 1.f);
    addFloatParam(LMFFreq, "LMFFreq", true, SAVE, &custom.LMFFreqValue, 90.f, 1400.f);
    addFloatParam(LMFQ, "LMFQ", true, SAVE, &custom.LMFQValue, 0.5, 3.f);
    addBoolParam(LMFPos, "LMFPos", true, SAVE, &custom.LMFPosBool);
    addBoolParam(LMFPN, "LMFPN", true, SAVE, &custom.LMFPNBool);
    addBoolParam(LMFEnable, "LMFEnable", true, SAVE, &custom.LMFEnableBool);
    addFloatParam(HMFGain, "HMFGain", true, SAVE, &custom.HMFGainValue, 0.f, 10.f);
    addFloatParam(HMFShape, "HMFShape", true, SAVE, &custom.HMFShapeValue, 0.f, 1.f);
    addFloatParam(HMFFreq, "HMFFreq", true, SAVE, &custom.HMFFreqValue, 400.f, 6000.f);
    addFloatParam(HMFQ, "HMFQ", true, SAVE, &custom.HMFQValue, 0.5, 3.f);
    addBoolParam(HMFPos, "HMFPos", true, SAVE, &custom.HMFPosBool);
    addBoolParam(HMFPN, "HMFPN", true, SAVE, &custom.HMFPNBool);
    addBoolParam(HMFEnable, "HMFEnable", true, SAVE, &custom.HMFEnableBool);
    addFloatParam(HFGain, "HFGain", true, SAVE, &custom.HFGainValue, 0.f, 10.f);
    addFloatParam(HFShape, "HFShape", true, SAVE, &custom.HFShapeValue, 0.f, 1.f);
    addFloatParam(HFFreq, "HFFreq", true, SAVE, &custom.HFFreqValue, 1500.f, 22000.f);
    addFloatParam(HFQ, "HFQ", true, SAVE, &custom.HFQValue, 0.5, 3.f);
    addBoolParam(HFPos, "HFPos", true, SAVE, &custom.HFPosBool);
    addBoolParam(HFPN, "HFPN", true, SAVE, &custom.HFPNBool);
    addBoolParam(HFEnable, "HFEnable", true, SAVE, &custom.HFEnableBool);
    addFloatParam(HPFreq, "HPFreq", true, SAVE, &custom.HPFreqValue, 20.f, 340.f);
    addFloatParam(HPQ, "HPQ", true, SAVE, &custom.HPQValue, 0.5, 3.f);
    addBoolParam(HPEnable, "HPEnable", true, SAVE, &custom.HPEnableBool);
    addFloatParam(LPFreq, "LPFreq", true, SAVE, &custom.LPFreqValue, 1500.f, 22000.f);
    addFloatParam(LPQ, "LPQ", true, SAVE, &custom.LPQValue, 0.5, 3.f);
    addBoolParam(LPEnable, "LPEnable", true, SAVE, &custom.LPEnableBool);
    
}

const String NewProjectAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String NewProjectAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool NewProjectAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool NewProjectAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool NewProjectAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool NewProjectAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

bool NewProjectAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double NewProjectAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int NewProjectAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int NewProjectAudioProcessor::getCurrentProgram()
{
    return 0;
}

void NewProjectAudioProcessor::setCurrentProgram (int index)
{
}

const String NewProjectAudioProcessor::getProgramName (int index)
{
    return String();
}

void NewProjectAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void NewProjectAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void NewProjectAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

//float NewProjectAudioProcessor::HighPassFilter(float buffer, int channel){
//    double Fs = getSampleRate();
//    double f0 = custom.get_HPFreqValue();
//    double Q = custom.get_HPQValue();
//    double K = tan(M_PI * (f0/Fs));
//    double norm = 1 / (1 + K/ Q + K * K);
//    double a0 = 1 * norm;
//    double a1 = -2 * a0;
//    double a2 = a0;
//    double b1 = 2 * (K * K - 1) * norm;
//    double b2 = (1 - K / Q + K * K) * norm;
//    
//    xHP[channel][2] = xHP[channel][1];
//    xHP[channel][1] = xHP[channel][0];
//    xHP[channel][0] = buffer;
//    yHP[channel][2] = yHP[channel][1];
//    yHP[channel][1] = yHP[channel][0];
//    
//    buffer = (a0*xHP[channel][0] + a1*xHP[channel][1] + a2*xHP[channel][2] - b1*yHP[channel][1] - b2*yHP[channel][2]);
//
//    yHP[channel][0] = buffer;
//    
//    return buffer;
//    
//}

float NewProjectAudioProcessor::LFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double V = pow(10, fabs(custom.get_LFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }

    
    xLFPeak[channel][2] = xLFPeak[channel][1];
    xLFPeak[channel][1] = xLFPeak[channel][0];
    xLFPeak[channel][0] = buffer;
    yLFPeak[channel][2] = yLFPeak[channel][1];
    yLFPeak[channel][1] = yLFPeak[channel][0];
    
    buffer = (a0*xLFPeak[channel][0] + a1*xLFPeak[channel][1] + a2*xLFPeak[channel][2] - b1*yLFPeak[channel][1] - b2*yLFPeak[channel][2]);
    
    yLFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::LFShelfFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double V = pow(10, fabs(custom.get_LFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (1 + sqrt(2*V)/Q * K + V * K * K) * norm;
        a1 = 2 * (V * K * K - 1) * norm;
        a2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + sqrt(2*V)/Q * K + V * K * K);
        a0 = (1+ sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (V * K * K - 1) * norm;
        b2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
    }
    xLFShelf[channel][2] = xLFShelf[channel][1];
    xLFShelf[channel][1] = xLFShelf[channel][0];
    xLFShelf[channel][0] = buffer;
    yLFShelf[channel][2] = yLFShelf[channel][1];
    yLFShelf[channel][1] = yLFShelf[channel][0];
    
    buffer = (a0*xLFShelf[channel][0] + a1*xLFShelf[channel][1] + a2*xLFShelf[channel][2] - b1*yLFShelf[channel][1] - b2*yLFShelf[channel][2]);
    
    yLFShelf[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::LFNotchFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K / Q + K * K);
    double a0 = (1 + K * K) * norm;
    double a1 = 2 * (K * K - 1) * norm;
    double a2 = a0;
    double b1 = a1;
    double b2 = (1 - K / Q + K * K) * norm;

    xLFNotch[channel][2] = xLFNotch[channel][1];
    xLFNotch[channel][1] = xLFNotch[channel][0];
    xLFNotch[channel][0] = buffer;
    yLFNotch[channel][2] = yLFNotch[channel][1];
    yLFNotch[channel][1] = yLFNotch[channel][0];
    
    buffer = (a0*xLFNotch[channel][0] + a1*xLFNotch[channel][1] + a2*xLFNotch[channel][2] - b1*yLFNotch[channel][1] - b2*yLFNotch[channel][2]);
    
    yLFNotch[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::LFAllpassFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double w0 = 2*M_PI*(f0/Fs);
    double alpha = sin(w0)/(2*Q);
    double b0 =   1.0 - alpha;
    double b1 =  (-2.0)*cos(w0);
    double b2 =   1.0 + alpha;
    double a0 =   1.0 + alpha;
    double a1 =  (-2.0)*cos(w0);
    double a2 =   1.0 - alpha;
    
    xLFAllpass[channel][2] = xLFAllpass[channel][1];
    xLFAllpass[channel][1] = xLFAllpass[channel][0];
    xLFAllpass[channel][0] = buffer;
    yLFAllpass[channel][2] = yLFAllpass[channel][1];
    yLFAllpass[channel][1] = yLFAllpass[channel][0];
    
    buffer = (b0/a0)*xLFAllpass[channel][0] + (b1/a0)*xLFAllpass[channel][1] + (b2/a0)*xLFAllpass[channel][2]
    - (a1/a0)*yLFAllpass[channel][1] - (a2/a0)*yLFAllpass[channel][2];
    
    yLFAllpass[channel][0] = buffer;
    
    return buffer;
}



float NewProjectAudioProcessor::LMFPeakFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LMFFreqValue();
    double Q = custom.get_LMFQValue();
    double V = pow(10, fabs(custom.get_LMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LMFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xLMFPeak[channel][2] = xLMFPeak[channel][1];
    xLMFPeak[channel][1] = xLMFPeak[channel][0];
    xLMFPeak[channel][0] = buffer;
    yLMFPeak[channel][2] = yLMFPeak[channel][1];
    yLMFPeak[channel][1] = yLMFPeak[channel][0];
    
    buffer = (a0*xLMFPeak[channel][0] + a1*xLMFPeak[channel][1] + a2*xLMFPeak[channel][2] - b1*yLMFPeak[channel][1] - b2*yLMFPeak[channel][2]);
    
    yLMFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::LMFShelfFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LMFFreqValue();
    double Q = custom.get_LMFQValue();
    double V = pow(10, fabs(custom.get_LMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LMFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (1 + sqrt(2*V)/Q * K + V * K * K) * norm;
        a1 = 2 * (V * K * K - 1) * norm;
        a2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + sqrt(2*V)/Q * K + V * K * K);
        a0 = (1+ sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (V * K * K - 1) * norm;
        b2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
    }
    xLMFShelf[channel][2] = xLMFShelf[channel][1];
    xLMFShelf[channel][1] = xLMFShelf[channel][0];
    xLMFShelf[channel][0] = buffer;
    yLMFShelf[channel][2] = yLMFShelf[channel][1];
    yLMFShelf[channel][1] = yLMFShelf[channel][0];
    
    buffer = (a0*xLMFShelf[channel][0] + a1*xLMFShelf[channel][1] + a2*xLMFShelf[channel][2] - b1*yLMFShelf[channel][1] - b2*yLMFShelf[channel][2]);
    
    yLMFShelf[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::LMFNotchFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LMFFreqValue();
    double Q = custom.get_LMFQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K / Q + K * K);
    double a0 = (1 + K * K) * norm;
    double a1 = 2 * (K * K - 1) * norm;
    double a2 = a0;
    double b1 = a1;
    double b2 = (1 - K / Q + K * K) * norm;
    
    xLMFNotch[channel][2] = xLMFNotch[channel][1];
    xLMFNotch[channel][1] = xLMFNotch[channel][0];
    xLMFNotch[channel][0] = buffer;
    yLMFNotch[channel][2] = yLMFNotch[channel][1];
    yLMFNotch[channel][1] = yLMFNotch[channel][0];
    
    buffer = (a0*xLMFNotch[channel][0] + a1*xLMFNotch[channel][1] + a2*xLMFNotch[channel][2] - b1*yLMFNotch[channel][1] - b2*yLMFNotch[channel][2]);
    
    yLMFNotch[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::HMFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HMFFreqValue();
    double Q = custom.get_HMFQValue();
    double V = pow(10, fabs(custom.get_HMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HMFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xHMFPeak[channel][2] = xHMFPeak[channel][1];
    xHMFPeak[channel][1] = xHMFPeak[channel][0];
    xHMFPeak[channel][0] = buffer;
    yHMFPeak[channel][2] = yHMFPeak[channel][1];
    yHMFPeak[channel][1] = yHMFPeak[channel][0];
    
    buffer = (a0*xHMFPeak[channel][0] + a1*xHMFPeak[channel][1] + a2*xHMFPeak[channel][2] - b1*yHMFPeak[channel][1] - b2*yHMFPeak[channel][2]);
    
    yHMFPeak[channel][0] = buffer;
    
    return buffer;
}



float NewProjectAudioProcessor::HMFShelfFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HMFFreqValue();
    double Q = custom.get_HMFQValue();
    double V = pow(10, fabs(custom.get_HMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HMFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (V + sqrt(2*V)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - V) * norm;
        a2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (V + sqrt(2*V)/Q * K + K * K);
        a0 = (1 + sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - V) * norm;
        b2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
    }
    
    
    xHMFShelf[channel][2] = xHMFShelf[channel][1];
    xHMFShelf[channel][1] = xHMFShelf[channel][0];
    xHMFShelf[channel][0] = buffer;
    yHMFShelf[channel][2] = yHMFShelf[channel][1];
    yHMFShelf[channel][1] = yHMFShelf[channel][0];
    
    buffer = (a0*xHMFShelf[channel][0] + a1*xHMFShelf[channel][1] + a2*xHMFShelf[channel][2] - b1*yHMFShelf[channel][1] - b2*yHMFShelf[channel][2]);
    
    yHMFShelf[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::HMFNotchFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_HMFFreqValue();
    double Q = custom.get_HMFQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K / Q + K * K);
    double a0 = (1 + K * K) * norm;
    double a1 = 2 * (K * K - 1) * norm;
    double a2 = a0;
    double b1 = a1;
    double b2 = (1 - K / Q + K * K) * norm;
    
    xHMFNotch[channel][2] = xHMFNotch[channel][1];
    xHMFNotch[channel][1] = xHMFNotch[channel][0];
    xHMFNotch[channel][0] = buffer;
    yHMFNotch[channel][2] = yHMFNotch[channel][1];
    yHMFNotch[channel][1] = yHMFNotch[channel][0];
    
    buffer = (a0*xHMFNotch[channel][0] + a1*xHMFNotch[channel][1] + a2*xHMFNotch[channel][2] - b1*yHMFNotch[channel][1] - b2*yHMFNotch[channel][2]);
    
    yHMFNotch[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::HFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HFFreqValue();
    double Q = custom.get_HFQValue();
    double V = pow(10, fabs(custom.get_HFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xHFPeak[channel][2] = xHFPeak[channel][1];
    xHFPeak[channel][1] = xHFPeak[channel][0];
    xHFPeak[channel][0] = buffer;
    yHFPeak[channel][2] = yHFPeak[channel][1];
    yHFPeak[channel][1] = yHFPeak[channel][0];
    
    buffer = (a0*xHFPeak[channel][0] + a1*xHFPeak[channel][1] + a2*xHFPeak[channel][2] - b1*yHFPeak[channel][1] - b2*yHFPeak[channel][2]);
    
    yHFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::HFShelfFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HFFreqValue();
    double Q = custom.get_HFQValue();
    double V = pow(10, fabs(custom.get_HFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (V + sqrt(2*V)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - V) * norm;
        a2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (V + sqrt(2*V)/Q * K + K * K);
        a0 = (1 + sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - V) * norm;
        b2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
    }
    
    
    xHFShelf[channel][2] = xHFShelf[channel][1];
    xHFShelf[channel][1] = xHFShelf[channel][0];
    xHFShelf[channel][0] = buffer;
    yHFShelf[channel][2] = yHFShelf[channel][1];
    yHFShelf[channel][1] = yHFShelf[channel][0];
    
    buffer = (a0*xHFShelf[channel][0] + a1*xHFShelf[channel][1] + a2*xHFShelf[channel][2] - b1*yHFShelf[channel][1] - b2*yHFShelf[channel][2]);
    
    yHFShelf[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::HFNotchFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_HFFreqValue();
    double Q = custom.get_HFQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K / Q + K * K);
    double a0 = (1 + K * K) * norm;
    double a1 = 2 * (K * K - 1) * norm;
    double a2 = a0;
    double b1 = a1;
    double b2 = (1 - K / Q + K * K) * norm;
    
    xHFNotch[channel][2] = xHFNotch[channel][1];
    xHFNotch[channel][1] = xHFNotch[channel][0];
    xHFNotch[channel][0] = buffer;
    yHFNotch[channel][2] = yHFNotch[channel][1];
    yHFNotch[channel][1] = yHFNotch[channel][0];
    
    buffer = (a0*xHFNotch[channel][0] + a1*xHFNotch[channel][1] + a2*xHFNotch[channel][2] - b1*yHFNotch[channel][1] - b2*yHFNotch[channel][2]);
    
    yHFNotch[channel][0] = buffer;
    
    return buffer;
    
}



void NewProjectAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    LP.set_Samplerate(getSampleRate());
    HP.set_Samplerate(getSampleRate());
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);
        
        // ..do something to the data...
        
        //Highpass Filter
        for (int i = 0; i < numSamples; i++) {
            if (custom.get_HPEnableBool() == true) {
                HP.set_Frequency(custom.get_HPFreqValue());
                HP.set_Q(custom.get_HPQValue());
                HP.calculateVariables();
                channelData[i] = HP.processSample(channelData[i], channel);
            }
        }
        //Lowpass Filter
        for (int i = 0; i < numSamples; i++) {
            if (custom.get_LPEnableBool() == true) {
                LP.set_Frequency(custom.get_LPFreqValue());
                LP.set_Q(custom.get_LPQValue());
                LP.calculateVariables();
                channelData[i] = LP.processSample(channelData[i], channel);
            }
        }
        
        for (int i = 0; i < numSamples; i++){
            //LFFilters
            if (custom.get_LFEnableBool() == true) {
                if(custom.get_LFPNBool() == false){
                    parallelChain1 = (LFPeakFilter(channelData[i], channel)*(1 - custom.get_LFShapeValue()))+(LFShelfFilter(channelData[i], channel)*custom.get_LFShapeValue());
                } else {
                    //parallelChain1 = LFNotchFilter(channelData[i], channel);
                    parallelChain1 = LFAllpassFilter(channelData[i], channel);
                }
            } else {
                parallelChain1 = channelData[i];
            }
            //LMFFilters
            if (custom.get_LMFEnableBool() == true) {
                if (custom.get_LMFPNBool() == false) {
                    parallelChain2 = (LMFPeakFilter(channelData[i], channel)*(1 - custom.get_LMFShapeValue()))+(LMFShelfFilter(channelData[i], channel)*custom.get_LMFShapeValue());
                } else {
                    parallelChain2 = LMFNotchFilter(channelData[i], channel);
                }
                
            } else {
                parallelChain2 = channelData[i];
            }
            
            //HMFFilters
            if (custom.get_HMFEnableBool() == true) {
                if (custom.get_HMFPNBool() == false){
                parallelChain1 = (HMFPeakFilter(parallelChain1, channel)*(1-custom.get_HMFShapeValue()))+(HMFShelfFilter(parallelChain1, channel)*custom.get_HMFShapeValue());
                } else {
                    parallelChain1 = HMFNotchFilter(parallelChain1, channel);
                }
            } else {
                parallelChain1 = parallelChain1;
            }
            
            //HFFilters
            if (custom.get_HFEnableBool() == true) {
                if (custom.get_HFPNBool() == false){
                parallelChain2 = (HFPeakFilter(parallelChain2, channel)*(1 - custom.get_HFShapeValue())) + (HFShelfFilter(parallelChain2, channel)*custom.get_HFShapeValue());
                } else {
                    parallelChain2 = HFNotchFilter(parallelChain2, channel);
                }
            } else {
                parallelChain1 = parallelChain1;
            }
            
            channelData[i] = (parallelChain1+parallelChain2)*0.5;
        }
        
        //protect your fucking ears!
        for (int i = 0; i < numSamples; i++) {
            if (channelData[i] > 1) {
                channelData[i] = 1;
            }
        }

    }
}

//==============================================================================
bool NewProjectAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* NewProjectAudioProcessor::createEditor()
{
    return new NewProjectAudioProcessorEditor (*this);
}

void NewProjectAudioProcessor::runAfterParamChange(int paramIndex, PluginParameters::UpdateFromFlags updateFromFlags){
    switch(paramIndex){
        case LFGain:    custom.set_LFGainValue(custom.LFGainValue);
        case LFShape:   custom.set_LFShapeValue(custom.LFShapeValue);
        case LFFreq:    custom.set_LFFreqValue(custom.LFFreqValue);
        case LFQ:       custom.set_LFQValue(custom.LFQValue);
        case LFPos:     custom.set_LFPosBool(custom.LFPosBool);
        case LFPN:      custom.set_LFPNBool(custom.LFPNBool);
        case LFEnable:  custom.set_LFEnableBool(custom.LFEnableBool);
        case LMFGain:   custom.set_LMFGainValue(custom.LMFGainValue);
        case LMFShape:  custom.set_LMFShapeValue(custom.LMFShapeValue);
        case LMFFreq:   custom.set_LMFFreqValue(custom.LMFFreqValue);
        case LMFQ:      custom.set_LMFQValue(custom.LMFQValue);
        case LMFPos:    custom.set_LMFPosBool(custom.LMFPosBool);
        case LMFPN:     custom.set_LMFPNBool(custom.LMFPNBool);
        case LMFEnable: custom.set_LMFEnableBool(custom.LMFEnableBool);
        case HMFGain:   custom.set_HMFGainValue(custom.HMFGainValue);
        case HMFShape:  custom.set_HMFShapeValue(custom.HMFShapeValue);
        case HMFFreq:   custom.set_HMFFreqValue(custom.HMFFreqValue);
        case HMFQ:      custom.set_HMFQValue(custom.HMFQValue);
        case HMFPos:    custom.set_HMFPosBool(custom.HMFPosBool);
        case HMFPN:     custom.set_HMFPNBool(custom.HMFPNBool);
        case HMFEnable: custom.set_HMFEnableBool(custom.HMFEnableBool);
        case HFGain:    custom.set_HFGainValue(custom.HFGainValue);
        case HFShape:   custom.set_HFShapeValue(custom.HFShapeValue);
        case HFFreq:    custom.set_HFFreqValue(custom.HFFreqValue);
        case HFQ:       custom.set_HFQValue(custom.HFQValue);
        case HFPos:     custom.set_HFPosBool(custom.HFPosBool);
        case HFPN:      custom.set_HFPNBool(custom.HFPNBool);
        case HFEnable:  custom.set_HFEnableBool(custom.HFEnableBool);
        case HPFreq:    custom.set_HPFreqValue(custom.HPFreqValue);
        case HPQ:       custom.set_HPQValue(custom.HPQValue);
        case HPEnable:  custom.set_HPEnableBool(custom.HPEnableBool);
        case LPFreq:    custom.set_LPFreqValue(custom.LPFreqValue);
        case LPQ:       custom.set_LPQValue(custom.LPQValue);
        case LPEnable:  custom.set_LPEnableBool(custom.LPEnableBool);
        default: break;
    }
}

const String NewProjectAudioProcessor::getParameterText (int index){
    return String (getParameter (index), 2);
}
//==============================================================================
void NewProjectAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    XmlElement xml ("MYPLUGINSETTINGS");
    xml.setAttribute("LFGain", custom.get_LFGainValue());
    xml.setAttribute("LFShape", custom.get_LFShapeValue());
    xml.setAttribute("LFFreq", custom.get_LFFreqValue());
    xml.setAttribute("LFQ", custom.get_LFQValue());
    xml.setAttribute("LMFGain", custom.get_LMFGainValue());
    xml.setAttribute("LMFShape", custom.get_LMFShapeValue());
    xml.setAttribute("LMFFreq", custom.get_LMFFreqValue());
    xml.setAttribute("LMFQ", custom.get_LMFQValue());
    xml.setAttribute("HMFGain", custom.get_HMFGainValue());
    xml.setAttribute("HMFShape", custom.get_HMFShapeValue());
    xml.setAttribute("HMFFreq", custom.get_HMFFreqValue());
    xml.setAttribute("HMFQ", custom.get_HMFQValue());
    xml.setAttribute("HFGain", custom.get_HFGainValue());
    xml.setAttribute("HFShape", custom.get_HFShapeValue());
    xml.setAttribute("HFFreq", custom.get_HFFreqValue());
    xml.setAttribute("HFQ", custom.get_HFQValue());
    xml.setAttribute("HPFreq", custom.get_HPFreqValue());
    xml.setAttribute("HPQ", custom.get_HPQValue());
    xml.setAttribute("LPFreq", custom.get_LPFreqValue());
    xml.setAttribute("LPQ", custom.get_LPQValue());
    xml.setAttribute("LFPos", custom.get_LFPosBool());
    xml.setAttribute("LFPN", custom.get_LFPNBool());
    xml.setAttribute("LFEnable", custom.get_LFEnableBool());
    xml.setAttribute("LMFPos", custom.get_LMFPosBool());
    xml.setAttribute("LMFPN", custom.get_LMFPNBool());
    xml.setAttribute("LMFEnable", custom.get_LMFEnableBool());
    xml.setAttribute("HMFPos", custom.get_HMFPosBool());
    xml.setAttribute("HMFPN", custom.get_HMFPNBool());
    xml.setAttribute("HMFEnable", custom.get_HMFEnableBool());
    xml.setAttribute("HFPos", custom.get_HFPosBool());
    xml.setAttribute("HFPN", custom.get_HFPNBool());
    xml.setAttribute("HFEnable", custom.get_HFEnableBool());
    xml.setAttribute("HPEnable", custom.get_HPEnableBool());
    xml.setAttribute("LPEnable", custom.get_LPEnableBool());
    
    copyXmlToBinary (xml, destData);
}

void NewProjectAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    if (xmlState != nullptr)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            /* ok, now pull out our parameters..
            lastUIWidth  = xmlState->getIntAttribute ("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);
            
            gain  = (float) xmlState->getDoubleAttribute ("gain", gain);
            delay = (float) xmlState->getDoubleAttribute ("delay", delay);
             */
            custom.set_LFGainValue(xmlState->getDoubleAttribute("LFGain"));
            custom.set_LFShapeValue(xmlState->getDoubleAttribute("LFShape"));
            custom.set_LFFreqValue(xmlState->getDoubleAttribute("LFFreq"));
            custom.set_LFQValue(xmlState->getDoubleAttribute("LFQ"));
            custom.set_LMFGainValue(xmlState->getDoubleAttribute("LMFGain"));
            custom.set_LMFShapeValue(xmlState->getDoubleAttribute("LMFShape"));
            custom.set_LMFFreqValue(xmlState->getDoubleAttribute("LMFFreq"));
            custom.set_LMFQValue(xmlState->getDoubleAttribute("LMFQ"));
            custom.set_HMFGainValue(xmlState->getDoubleAttribute("HMFGain"));
            custom.set_HMFShapeValue(xmlState->getDoubleAttribute("HMFShape"));
            custom.set_HMFFreqValue(xmlState->getDoubleAttribute("HMFFreq"));
            custom.set_HMFQValue(xmlState->getDoubleAttribute("HMFQ"));
            custom.set_HFGainValue(xmlState->getDoubleAttribute("HFGain"));
            custom.set_HFShapeValue(xmlState->getDoubleAttribute("HFShape"));
            custom.set_HFFreqValue(xmlState->getDoubleAttribute("HFFreq"));
            custom.set_HFQValue(xmlState->getDoubleAttribute("HFQ"));
            custom.set_HPFreqValue(xmlState->getDoubleAttribute("HPFreq"));
            custom.set_HPQValue(xmlState->getDoubleAttribute("HPQ"));
            custom.set_LPFreqValue(xmlState->getDoubleAttribute("LPFreq"));
            custom.set_LPQValue(xmlState->getDoubleAttribute("LPQ"));
            custom.set_LFPosBool(xmlState->getBoolAttribute("LFPos"));
            custom.set_LFPNBool(xmlState->getBoolAttribute("LFPN"));
            custom.set_LFEnableBool(xmlState->getBoolAttribute("LFEnable"));
            custom.set_LMFPosBool(xmlState->getBoolAttribute("LMFPos"));
            custom.set_LMFPNBool(xmlState->getBoolAttribute("LMFPN"));
            custom.set_LMFEnableBool(xmlState->getBoolAttribute("LMFEnable"));
            custom.set_HMFPosBool(xmlState->getBoolAttribute("HMFPos"));
            custom.set_HMFPNBool(xmlState->getBoolAttribute("HMFPN"));
            custom.set_HMFEnableBool(xmlState->getBoolAttribute("HMFEnable"));
            custom.set_HFPosBool(xmlState->getBoolAttribute("HFPos"));
            custom.set_HFPNBool(xmlState->getBoolAttribute("HFPN"));
            custom.set_HFEnableBool(xmlState->getBoolAttribute("HFEnable"));
            custom.set_HPEnableBool(xmlState->getBoolAttribute("HPEnable"));
            custom.set_LPEnableBool(xmlState->getBoolAttribute("LPEnable"));
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new NewProjectAudioProcessor();
}
