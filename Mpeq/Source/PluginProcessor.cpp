/*
 ==============================================================================
 
 This file was auto-generated by the Introjucer!
 
 It contains the basic framework code for a JUCE plugin processor.
 
 ==============================================================================
 */

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <math.h>


//==============================================================================
NewProjectAudioProcessor::NewProjectAudioProcessor()
{
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            xLP[i][j] = 0;
            yLP[i][j] = 0;
            xHP[i][j] = 0;
            yHP[i][j] = 0;
            
            xLFPeak[i][j] = 0;
            yLFPeak[i][j] = 0;
            xLFShelf[i][j] = 0;
            yLFShelf[i][j] = 0;
            
            xLMFPeak[i][j] = 0;
            yLMFPeak[i][j] = 0;
            xLMFShelf[i][j] = 0;
            yLMFShelf[i][j] = 0;
            
            xHMFPeak[i][j] = 0;
            yHMFPeak[i][j] = 0;
            xHMFShelf[i][j] = 0;
            yHMFShelf[i][j] = 0;
            
            xHFPeak[i][j] = 0;
            yHFPeak[i][j] = 0;
        }
    }
}

NewProjectAudioProcessor::~NewProjectAudioProcessor()
{
}

//==============================================================================
const String NewProjectAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int NewProjectAudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float NewProjectAudioProcessor::getParameter (int index)
{
    switch (index)
    {
        case LFGain:        return  custom.get_LFGainValue();
        case LFShape:       return  custom.get_LFShapeValue();
        case LFFreq:        return  custom.get_LFFreqValue();
        case LFQ:           return  custom.get_LFQValue();
        case LFPos:         return  custom.get_LFPosBool();
        case LFPN:          return  custom.get_LFPNBool();
        case LFEnable:      return  custom.get_LFEnableBool();
        case LMFGain:       return  custom.get_LMFGainValue();
        case LMFShape:      return  custom.get_LMFShapeValue();
        case LMFFreq:       return  custom.get_LMFFreqValue();
        case LMFQ:          return  custom.get_LMFQValue();
        case LMFPos:        return  custom.get_LMFPosBool();
        case LMFPN:         return  custom.get_LMFPNBool();
        case LMFEnable:     return  custom.get_LMFEnableBool();
        case HMFGain:       return  custom.get_HMFGainValue();
        case HMFShape:      return  custom.get_HMFShapeValue();
        case HMFFreq:       return  custom.get_HMFFreqValue();
        case HMFQ:          return  custom.get_HMFQValue();
        case HMFPos:        return  custom.get_HMFPosBool();
        case HMFPN:         return  custom.get_HMFPNBool();
        case HMFEnable:     return  custom.get_HMFEnableBool();
        case HFGain:        return  custom.get_HFGainValue();
        case HFShape:       return  custom.get_HFShapeValue();
        case HFFreq:        return  custom.get_HFFreqValue();
        case HFQ:           return  custom.get_HFQValue();
        case HFPos:         return  custom.get_HFPosBool();
        case HFPN:          return  custom.get_HFPNBool();
        case HFEnable:      return  custom.get_HFEnableBool();
        case HPFreq:        return  custom.get_HPFreqValue();
        case HPQ:           return  custom.get_HPQValue();
        case HPEnable:      return  custom.get_HPEnableBool();
        case LPFreq:        return  custom.get_LPFreqValue();
        case LPQ:           return  custom.get_LPQValue();
        case LPEnable:      return  custom.get_LPEnableBool();
        default:            return 0.0f;
    }
}

void NewProjectAudioProcessor::setParameter (int index, float newValue)
{
    switch (index)
    {
        case LFGain:        custom.set_LFGainValue(newValue); break;
        case LFShape:       custom.set_LFShapeValue(newValue); break;
        case LFFreq:        custom.set_LFFreqValue(newValue); break;
        case LFQ:           custom.set_LFQValue(newValue); break;
        case LFPos:         custom.set_LFPosBool(newValue); break;
        case LFPN:          custom.set_LFPNBool(newValue); break;
        case LFEnable:      custom.set_LFEnableBool(newValue); break;
        case LMFGain:       custom.set_LMFGainValue(newValue); break;
        case LMFShape:      custom.set_LMFShapeValue(newValue); break;
        case LMFFreq:       custom.set_LMFFreqValue(newValue); break;
        case LMFQ:          custom.set_LMFQValue(newValue); break;
        case LMFPos:        custom.set_LMFPosBool(newValue); break;
        case LMFPN:         custom.set_LMFPNBool(newValue); break;
        case LMFEnable:     custom.set_LMFEnableBool(newValue); break;
        case HMFGain:       custom.set_HMFGainValue(newValue); break;
        case HMFShape:      custom.set_HMFShapeValue(newValue); break;
        case HMFFreq:       custom.set_HMFFreqValue(newValue); break;
        case HMFQ:          custom.set_HMFQValue(newValue); break;
        case HMFPos:        custom.set_HMFPosBool(newValue); break;
        case HMFPN:         custom.set_HMFPNBool(newValue); break;
        case HMFEnable:     custom.set_HMFEnableBool(newValue); break;
        case HFGain:        custom.set_HFGainValue(newValue); break;
        case HFShape:       custom.set_HFShapeValue(newValue); break;
        case HFFreq:        custom.set_HFFreqValue(newValue); break;
        case HFQ:           custom.set_HFQValue(newValue); break;
        case HFPos:         custom.set_HFPosBool(newValue); break;
        case HFPN:          custom.set_HFPNBool(newValue); break;
        case HFEnable:      custom.set_HFEnableBool(newValue); break;
        case HPFreq:        custom.set_HPFreqValue(newValue); break;
        case HPQ:           custom.set_HPQValue(newValue); break;
        case HPEnable:      custom.set_HPEnableBool(newValue); break;
        case LPFreq:        custom.set_LPFreqValue(newValue); break;
        case LPQ:           custom.set_LPQValue(newValue); break;
        case LPEnable:      custom.set_LPEnableBool(newValue); break;
        default:            break;
    }
}

const String NewProjectAudioProcessor::getParameterName (int index)
{
    switch (index)
    {
        case LFGain:        return  "LF:Gain";
        case LFShape:       return  "LF:Shape";
        case LFFreq:        return  "LF:Freq";
        case LFQ:           return  "LF:Q";
        case LFPos:         return  "LF:Gain Pos./Neg.";
        case LFPN:          return  "LF:Peak/Notch";
        case LFEnable:      return  "LF:Enable";
        case LMFGain:       return  "LMF:Gain";
        case LMFShape:      return  "LMF:Shape";
        case LMFFreq:       return  "LMF:Freq";
        case LMFQ:          return  "LMF:Q";
        case LMFPos:        return  "LMF:Gain Pos./Neg.";
        case LMFPN:         return  "LMF:Peak/Notch";
        case LMFEnable:     return  "LMF:Enable";
        case HMFGain:       return  "HMF:Gain";
        case HMFShape:      return  "HMF:Shape";
        case HMFFreq:       return  "HMF:Freq";
        case HMFQ:          return  "HMF:Q";
        case HMFPos:        return  "HMF:Gain Pos./Neg.";
        case HMFPN:         return  "HMF:Peak/Notch";
        case HMFEnable:     return  "HMFEnable";
        case HFGain:        return  "HF:Gain";
        case HFShape:       return  "HF:Shape";
        case HFFreq:        return  "HF:Freq";
        case HFQ:           return  "HF:Q";
        case HFPos:         return  "HF:Gain Pos./Neg.";
        case HFPN:          return  "HF:Peak/Notch";
        case HFEnable:      return  "HF:Enable";
        case HPFreq:        return  "HP:Freq";
        case HPQ:           return  "HP:Q";
        case HPEnable:      return  "HP:Enable";
        case LPFreq:        return  "LP:Freq";
        case LPQ:           return  "LP:Q";
        case LPEnable:      return  "LP:Enable";
        default:            break;
    }
    return String::empty;
}

const String NewProjectAudioProcessor::getParameterText (int index)
{
    switch (index)
    {
        case LFGain:        return  "LF:Gain";
        case LFShape:       return  "LF:Shape";
        case LFFreq:        return  "LF:Freq";
        case LFQ:           return  "LF:Q";
        case LFPos:         return  "LF:Gain Pos./Neg.";
        case LFPN:          return  "LF:Peak/Notch";
        case LFEnable:      return  "LF:Enable";
        case LMFGain:       return  "LMF:Gain";
        case LMFShape:      return  "LMF:Shape";
        case LMFFreq:       return  "LMF:Freq";
        case LMFQ:          return  "LMF:Q";
        case LMFPos:        return  "LMF:Gain Pos./Neg.";
        case LMFPN:         return  "LMF:Peak/Notch";
        case LMFEnable:     return  "LMF:Enable";
        case HMFGain:       return  "HMF:Gain";
        case HMFShape:      return  "HMF:Shape";
        case HMFFreq:       return  "HMF:Freq";
        case HMFQ:          return  "HMF:Q";
        case HMFPos:        return  "HMF:Gain Pos./Neg.";
        case HMFPN:         return  "HMF:Peak/Notch";
        case HMFEnable:     return  "HMFEnable";
        case HFGain:        return  "HF:Gain";
        case HFShape:       return  "HF:Shape";
        case HFFreq:        return  "HF:Freq";
        case HFQ:           return  "HF:Q";
        case HFPos:         return  "HF:Gain Pos./Neg.";
        case HFPN:          return  "HF:Peak/Notch";
        case HFEnable:      return  "HF:Enable";
        case HPFreq:        return  "HP:Freq";
        case HPQ:           return  "HP:Q";
        case HPEnable:      return  "HP:Enable";
        case LPFreq:        return  "LP:Freq";
        case LPQ:           return  "LP:Q";
        case LPEnable:      return  "LP:Enable";
        default:            break;
    }
    return String::empty;
}

const String NewProjectAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String NewProjectAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool NewProjectAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool NewProjectAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool NewProjectAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool NewProjectAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

bool NewProjectAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double NewProjectAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int NewProjectAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int NewProjectAudioProcessor::getCurrentProgram()
{
    return 0;
}

void NewProjectAudioProcessor::setCurrentProgram (int index)
{
}

const String NewProjectAudioProcessor::getProgramName (int index)
{
    return String();
}

void NewProjectAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void NewProjectAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void NewProjectAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

double NewProjectAudioProcessor::dBToAmplitude(double dB){
    return pow(10, (dB/20));
}

float NewProjectAudioProcessor::LowPassFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LPFreqValue();
    double Q = custom.get_LPQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K / Q + K * K);
    double a0 = K * K * norm;
    double a1 = 2 * a0;
    double a2 = a0;
    double b1 = 2 * (K * K -1) * norm;
    double b2 = (1 -K / Q + K * K) * norm;
    
    
        xLP[channel][2] = xLP[channel][1];
        xLP[channel][1] = xLP[channel][0];
        xLP[channel][0] = buffer;
        yLP[channel][2] = yLP[channel][1];
        yLP[channel][1] = yLP[channel][0];
        
        buffer = (a0*xLP[channel][0] + a1*xLP[channel][1] + a2*xLP[channel][2] - b1*yLP[channel][1] - b2*yLP[channel][2]);
        
    yLP[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::HighPassFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_HPFreqValue();
    double Q = custom.get_HPQValue();
    double K = tan(M_PI * (f0/Fs));
    double norm = 1 / (1 + K/ Q + K * K);
    double a0 = 1 * norm;
    double a1 = -2 * a0;
    double a2 = a0;
    double b1 = 2 * (K * K - 1) * norm;
    double b2 = (1 - K / Q + K * K) * norm;
    
    xHP[channel][2] = xHP[channel][1];
    xHP[channel][1] = xHP[channel][0];
    xHP[channel][0] = buffer;
    yHP[channel][2] = yHP[channel][1];
    yHP[channel][1] = yHP[channel][0];
    
    buffer = (a0*xHP[channel][0] + a1*xHP[channel][1] + a2*xHP[channel][2] - b1*yHP[channel][1] - b2*yHP[channel][2]);

    yHP[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::LFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double V = pow(10, fabs(custom.get_LFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }

    
    xLFPeak[channel][2] = xLFPeak[channel][1];
    xLFPeak[channel][1] = xLFPeak[channel][0];
    xLFPeak[channel][0] = buffer;
    yLFPeak[channel][2] = yLFPeak[channel][1];
    yLFPeak[channel][1] = yLFPeak[channel][0];
    
    buffer = (a0*xLFPeak[channel][0] + a1*xLFPeak[channel][1] + a2*xLFPeak[channel][2] - b1*yLFPeak[channel][1] - b2*yLFPeak[channel][2]);
    
    yLFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::LFShelfFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LFFreqValue();
    double Q = custom.get_LFQValue();
    double V = pow(10, fabs(custom.get_LFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (1 + sqrt(2*V)/Q * K + V * K * K) * norm;
        a1 = 2 * (V * K * K - 1) * norm;
        a2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + sqrt(2*V)/Q * K + V * K * K);
        a0 = (1+ sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (V * K * K - 1) * norm;
        b2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
    }
    xLFShelf[channel][2] = xLFShelf[channel][1];
    xLFShelf[channel][1] = xLFShelf[channel][0];
    xLFShelf[channel][0] = buffer;
    yLFShelf[channel][2] = yLFShelf[channel][1];
    yLFShelf[channel][1] = yLFShelf[channel][0];
    
    buffer = (a0*xLFShelf[channel][0] + a1*xLFShelf[channel][1] + a2*xLFShelf[channel][2] - b1*yLFShelf[channel][1] - b2*yLFShelf[channel][2]);
    
    yLFShelf[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::LMFPeakFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LMFFreqValue();
    double Q = custom.get_LMFQValue();
    double V = pow(10, fabs(custom.get_LMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LMFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xLMFPeak[channel][2] = xLMFPeak[channel][1];
    xLMFPeak[channel][1] = xLMFPeak[channel][0];
    xLMFPeak[channel][0] = buffer;
    yLMFPeak[channel][2] = yLMFPeak[channel][1];
    yLMFPeak[channel][1] = yLMFPeak[channel][0];
    
    buffer = (a0*xLMFPeak[channel][0] + a1*xLMFPeak[channel][1] + a2*xLMFPeak[channel][2] - b1*yLMFPeak[channel][1] - b2*yLMFPeak[channel][2]);
    
    yLMFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::LMFShelfFilter(float buffer, int channel){
    double Fs = getSampleRate();
    double f0 = custom.get_LMFFreqValue();
    double Q = custom.get_LMFQValue();
    double V = pow(10, fabs(custom.get_LMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_LMFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (1 + sqrt(2*V)/Q * K + V * K * K) * norm;
        a1 = 2 * (V * K * K - 1) * norm;
        a2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + sqrt(2*V)/Q * K + V * K * K);
        a0 = (1+ sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (V * K * K - 1) * norm;
        b2 = (1 - sqrt(2*V)/Q * K + V * K * K) * norm;
    }
    xLMFShelf[channel][2] = xLMFShelf[channel][1];
    xLMFShelf[channel][1] = xLMFShelf[channel][0];
    xLMFShelf[channel][0] = buffer;
    yLMFShelf[channel][2] = yLMFShelf[channel][1];
    yLMFShelf[channel][1] = yLMFShelf[channel][0];
    
    buffer = (a0*xLMFShelf[channel][0] + a1*xLMFShelf[channel][1] + a2*xLMFShelf[channel][2] - b1*yLMFShelf[channel][1] - b2*yLMFShelf[channel][2]);
    
    yLMFShelf[channel][0] = buffer;
    
    return buffer;
    
}

float NewProjectAudioProcessor::HMFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HMFFreqValue();
    double Q = custom.get_HMFQValue();
    double V = pow(10, fabs(custom.get_HMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HMFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xHMFPeak[channel][2] = xHMFPeak[channel][1];
    xHMFPeak[channel][1] = xHMFPeak[channel][0];
    xHMFPeak[channel][0] = buffer;
    yHMFPeak[channel][2] = yHMFPeak[channel][1];
    yHMFPeak[channel][1] = yHMFPeak[channel][0];
    
    buffer = (a0*xHMFPeak[channel][0] + a1*xHMFPeak[channel][1] + a2*xHMFPeak[channel][2] - b1*yHMFPeak[channel][1] - b2*yHMFPeak[channel][2]);
    
    yHMFPeak[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::HMFShelfFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HMFFreqValue();
    double Q = custom.get_HMFQValue();
    double V = pow(10, fabs(custom.get_HMFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HMFPosBool() == false) {
        norm = 1 / (1 + sqrt(2)/Q * K + K * K);
        a0 = (V + sqrt(2*V)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - V) * norm;
        a2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - 1) * norm;
        b2 = (1 - sqrt(2)/Q * K + K * K) * norm;
    } else {
        norm = 1 / (V + sqrt(2*V)/Q * K + K * K);
        a0 = (1 + sqrt(2)/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - sqrt(2)/Q * K + K * K) * norm;
        b1 = 2 * (K * K - V) * norm;
        b2 = (V - sqrt(2*V)/Q * K + K * K) * norm;
    }
    
    
    xHMFShelf[channel][2] = xHMFShelf[channel][1];
    xHMFShelf[channel][1] = xHMFShelf[channel][0];
    xHMFShelf[channel][0] = buffer;
    yHMFShelf[channel][2] = yHMFShelf[channel][1];
    yHMFShelf[channel][1] = yHMFShelf[channel][0];
    
    buffer = (a0*xHMFShelf[channel][0] + a1*xHMFShelf[channel][1] + a2*xHMFShelf[channel][2] - b1*yHMFShelf[channel][1] - b2*yHMFShelf[channel][2]);
    
    yHMFShelf[channel][0] = buffer;
    
    return buffer;
}

float NewProjectAudioProcessor::HFPeakFilter(float buffer, int channel){
    
    double Fs = getSampleRate();
    double f0 = custom.get_HFFreqValue();
    double Q = custom.get_HFQValue();
    double V = pow(10, fabs(custom.get_HFGainValue())/ 20.0);
    double K = tan(M_PI * (f0/Fs));
    double norm;
    double a0;
    double a1;
    double a2;
    double b1;
    double b2;
    if (custom.get_HFPosBool() == false) {
        norm = 1 / (1 + 1/Q * K + K * K);
        a0 = (1 + V/Q * K + K * K) * norm;
        a1 = 2 * (K * K -1) * norm;
        a2 = (1 - V/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - 1/Q * K + K * K) * norm;
    } else {
        norm = 1 / (1 + V/Q * K + K * K);
        a0 = (1 + 1/Q * K + K * K) * norm;
        a1 = 2 * (K * K - 1) * norm;
        a2 = (1 - 1/Q * K + K * K) * norm;
        b1 = a1;
        b2 = (1 - V/Q * K + K * K) * norm;
    }
    
    
    xHFPeak[channel][2] = xHFPeak[channel][1];
    xHFPeak[channel][1] = xHFPeak[channel][0];
    xHFPeak[channel][0] = buffer;
    yHFPeak[channel][2] = yHFPeak[channel][1];
    yHFPeak[channel][1] = yHFPeak[channel][0];
    
    buffer = (a0*xHFPeak[channel][0] + a1*xHFPeak[channel][1] + a2*xHFPeak[channel][2] - b1*yHFPeak[channel][1] - b2*yHFPeak[channel][2]);
    
    yHFPeak[channel][0] = buffer;
    
    return buffer;
}




void NewProjectAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);
        
        // ..do something to the data...
        
        //Highpass Filter
        for (int i = 0; i < numSamples; i++) {
            if (custom.get_HPEnableBool() == true) {
                channelData[i] = HighPassFilter(channelData[i], channel);
            }
        }
        //Lowpass Filter
        for (int i = 0; i < numSamples; i++) {
            if (custom.get_LPEnableBool() == true) {
                channelData[i] = LowPassFilter(channelData[i], channel);
            }
        }
        
        for (int i = 0; i < numSamples; i++){
            //LFFilters
            if (custom.get_LFEnableBool() == true) {
                parallelChain1 = (LFPeakFilter(channelData[i], channel)*(1 - custom.get_LFShapeValue()))+(LFShelfFilter(channelData[i], channel)*custom.get_LFShapeValue());
            } else {
                parallelChain1 = channelData[i];
            }
            //LMFFilters
            if (custom.get_LMFEnableBool() == true) {
                parallelChain2 = (LMFPeakFilter(channelData[i], channel)*(1 - custom.get_LMFShapeValue()))+(LMFShelfFilter(channelData[i], channel)*custom.get_LMFShapeValue());
            } else {
                parallelChain2 = channelData[i];
            }
            
            //HMFFilters
            if (custom.get_HMFEnableBool() == true) {
                parallelChain1 = (HMFPeakFilter(parallelChain1, channel)*(1-custom.get_HMFShapeValue()))+(HMFShelfFilter(parallelChain1, channel)*custom.get_HMFShapeValue());
            } else {
                parallelChain1 = parallelChain1;
            }
            
            //HFPeakFilter
            if (custom.get_HFEnableBool() == true) {
                parallelChain2 = HFPeakFilter(parallelChain2, channel);
            } else {
                parallelChain1 = parallelChain1;
            }
            
            channelData[i] = (parallelChain1+parallelChain2)*0.5;
        }
        
        //protect your fucking ears!
        for (int i = 0; i < numSamples; i++) {
            if (channelData[i] > 1) {
                channelData[i] = 1;
            }
        }

    }
}

//==============================================================================
bool NewProjectAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* NewProjectAudioProcessor::createEditor()
{
    return new NewProjectAudioProcessorEditor (*this);
}

//==============================================================================
void NewProjectAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    XmlElement xml ("MYPLUGINSETTINGS");
    xml.setAttribute("LFGain", custom.get_LFGainValue());
    xml.setAttribute("LFShape", custom.get_LFShapeValue());
    xml.setAttribute("LFFreq", custom.get_LFFreqValue());
    xml.setAttribute("LFQ", custom.get_LFQValue());
    xml.setAttribute("LMFGain", custom.get_LMFGainValue());
    xml.setAttribute("LMFShape", custom.get_LMFShapeValue());
    xml.setAttribute("LMFFreq", custom.get_LMFFreqValue());
    xml.setAttribute("LMFQ", custom.get_LMFQValue());
    xml.setAttribute("HMFGain", custom.get_HMFGainValue());
    xml.setAttribute("HMFShape", custom.get_HMFShapeValue());
    xml.setAttribute("HMFFreq", custom.get_HMFFreqValue());
    xml.setAttribute("HMFQ", custom.get_HMFQValue());
    xml.setAttribute("HFGain", custom.get_HFGainValue());
    xml.setAttribute("HFShape", custom.get_HFShapeValue());
    xml.setAttribute("HFFreq", custom.get_HFFreqValue());
    xml.setAttribute("HFQ", custom.get_HFQValue());
    xml.setAttribute("HPFreq", custom.get_HPFreqValue());
    xml.setAttribute("HPQ", custom.get_HPQValue());
    xml.setAttribute("LPFreq", custom.get_LPFreqValue());
    xml.setAttribute("LPQ", custom.get_LPQValue());
    xml.setAttribute("LFPos", custom.get_LFPosBool());
    xml.setAttribute("LFPN", custom.get_LFPNBool());
    xml.setAttribute("LFEnable", custom.get_LFEnableBool());
    xml.setAttribute("LMFPos", custom.get_LMFPosBool());
    xml.setAttribute("LMFPN", custom.get_LMFPNBool());
    xml.setAttribute("LMFEnable", custom.get_LMFEnableBool());
    xml.setAttribute("HMFPos", custom.get_HMFPosBool());
    xml.setAttribute("HMFPN", custom.get_HMFPNBool());
    xml.setAttribute("HMFEnable", custom.get_HMFEnableBool());
    xml.setAttribute("HFPos", custom.get_HFPosBool());
    xml.setAttribute("HFPN", custom.get_HFPNBool());
    xml.setAttribute("HFEnable", custom.get_HFEnableBool());
    xml.setAttribute("HPEnable", custom.get_HPEnableBool());
    xml.setAttribute("LPEnable", custom.get_LPEnableBool());
    
    copyXmlToBinary (xml, destData);
}

void NewProjectAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    if (xmlState != nullptr)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            /* ok, now pull out our parameters..
            lastUIWidth  = xmlState->getIntAttribute ("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);
            
            gain  = (float) xmlState->getDoubleAttribute ("gain", gain);
            delay = (float) xmlState->getDoubleAttribute ("delay", delay);
             */
            
            custom.set_LPEnableBool(xmlState->getBoolAttribute("LPEnable"));
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new NewProjectAudioProcessor();
}
